<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uw Bedrijfsnaam | Parametrische Lade-Indeling</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-csg-ts@3.1.11/dist/index.js"></script>

    <style>
        /* GLOBALE EN LAYOUT STIJLEN */
        :root {
            --primary-color: #0275d8; /* Diep Blauw */
            --secondary-color: #f0ad4e; /* Oranje */
            --dark-text: #333;
            --light-bg: #f4f4f4;
            --panel-bg: white;
            --header-height: 70px;
        }

        body { 
            margin: 0; 
            font-family: 'Arial', sans-serif; 
            background-color: var(--light-bg); 
            color: var(--dark-text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* HEADER & NAVIGATIE */
        #header {
            background-color: var(--dark-text);
            color: white;
            height: var(--header-height);
            padding: 0 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 200;
        }
        #header h1 { margin: 0; font-size: 24px; }
        #header nav a { color: white; text-decoration: none; margin-left: 25px; font-weight: 500; transition: color 0.3s; }
        #header nav a:hover { color: var(--secondary-color); }

        /* MAIN WEBSITE GRID LAYOUT */
        #main-grid {
            flex-grow: 1;
            display: grid;
            /* Definitie van de kolommen: Info | Grote Tool | Winkelmandje */
            grid-template-columns: 250px 1fr 250px; 
            height: calc(100vh - var(--header-height));
        }

        /* LINKS PANEEL (Tekst & Uitleg) */
        #info-panel {
            background-color: var(--panel-bg);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            border-right: 1px solid #ddd;
        }
        #info-panel h2 { margin-top: 0; color: var(--primary-color); font-size: 1.4em; }

        /* MIDDEN PANEEL (3D Tool & Parameters) */
        #tool-container {
            position: relative;
            background-color: var(--light-bg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #tool-header {
            background-color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #container { /* De 3D Viewport */
            flex-grow: 1;
            width: 100%;
            position: relative; 
            overflow: hidden;
        }

        /* RECHTS PANEEL (Parameters & Acties) */
        #sidebar {
            background: var(--panel-bg);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
            border-left: 1px solid #ddd;
        }
        #sidebar h2 { margin-top: 0; color: var(--secondary-color); font-size: 1.2em; }
        
        /* KNOPPEN & INPUT STIJLEN (ongewijzigd) */
        .input-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px; }
        .input-group input, .input-group select { width: 90%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .button-group { display: flex; justify-content: space-between; margin-top: 10px; }
        button { padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-top: 5px; font-weight: bold; transition: background-color 0.3s; width: 100%; }

        #updateButton, #updateVakButton { background-color: #28a745; color: white; }
        #updateButton:hover, #updateVakButton:hover { background-color: #218838; }

        #addDividerV_Partial, #addDividerH_Partial, #addDividerV_Full, #addDividerH_Full, #renderDetailsButton { 
            background-color: var(--secondary-color); 
            color: var(--dark-text);
            width: 48%; 
        }
        #addDividerV_Partial:hover, #addDividerH_Partial:hover, #addDividerV_Full:hover, #addDividerH_Full:hover, #renderDetailsButton:hover { 
            background-color: #e09d2e; 
        }
        
        #resetButton { background-color: #5bc0de; width: 100%; }
        #resetButton:hover { background-color: #31b0d5; }
        
        #exportButton, #toggleExplodedViewButton, #addToCartButton { background-color: var(--primary-color); color: white; margin-top: 15px; }
        #exportButton:hover, #toggleExplodedViewButton:hover, #addToCartButton:hover { background-color: #025aa5; }

        #deleteDividerButton { background-color: #d9534f; margin-top: 10px; }
        #deleteDividerButton:hover { background-color: #c9302c; }

        #toggleExplodedViewButton { display: none; }

        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-family: sans-serif;
            z-index: 1000;
        }

        /* FOOTER */
        #footer {
            background-color: var(--dark-text);
            color: white;
            text-align: center;
            padding: 10px;
            font-size: 12px;
            z-index: 200;
        }
    </style>
</head>
<body>
    
    <header id="header">
        <h1>üõ†Ô∏è CUSTOM LADE-INDELING</h1>
        <nav>
            <a href="#">Over Ons</a>
            <a href="#">Contact</a>
            <button id="addToCartButton" onclick="alert('Winkelmandje logica moet hier komen!')" style="width: auto; margin: 0; padding: 10px 20px;">üõí Winkelmandje (0)</button>
        </nav>
    </header>

    <div id="main-grid">
        
        <aside id="info-panel">
            <h2>Welkom bij de Ontwerp Studio</h2>
            <p>Ontwerp uw perfecte lade-indeling op basis van de exacte afmetingen van uw lade. Wij zagen de planken op maat en sturen ze met de juiste verbindingen naar u toe.</p>
            
            <h3>Gebruiksaanwijzing:</h3>
            <ol style="padding-left: 20px; font-size: 0.9em;">
                <li>**Start:** Voer de buitenmaten (B/D/H) van uw lade in rechts.</li>
                <li>**Splits:** Gebruik de knoppen "(V) Splits" en "(H) Splits" om nieuwe vakken te maken.</li>
                <li>**Aanpassen:** Klik op een vak om de binnenmaten direct te wijzigen.</li>
                <li>**Controle:** Gebruik "Bekijk Verbindingen" om de Dado- en Half-Lap verbindingen te controleren.</li>
            </ol>

            <h3 style="border-top: 1px solid #eee; padding-top: 10px;">Productie Informatie</h3>
            <p style="font-size: 0.9em;">
                Wij gebruiken **Half-Lap** verbindingen bij kruisingen en **Dado (gleuf)** verbindingen tegen de lade-wanden voor de meest stabiele en makkelijke montage.
            </p>
        </aside>

        <div id="tool-container">
            <div id="tool-header">
                <h2 style="margin: 0; font-size: 1.5em; color: var(--dark-text);">3D Lade Model</h2>
                <p id="layout-status" style="margin: 0; font-style: italic; font-size: 0.9em;">Status: Initialisatie...</p>
            </div>
            <div id="container"></div>
        </div>

        <div id="sidebar">
            <h2 style="border-bottom: 1px solid #ddd; padding-bottom: 5px;">Configuratie Controls</h2>
            
            <div class="input-group">
                <label for="materialSelect">Materiaal Keuze</label>
                <select id="materialSelect" onchange="updateDrawerDimensions(false)">
                    <option value="light_oak" selected>Licht Eiken</option>
                    <option value="dark_walnut">Donker Noten</option>
                </select>
            </div>

            <div class="input-group">
                <label for="drawerWidthInput">Breedte (W) Buitenmaat</label>
                <input type="number" id="drawerWidthInput" value="600" min="200" step="1">
                <label for="drawerDepthInput">Diepte (D) Buitenmaat</label>
                <input type="number" id="drawerDepthInput" value="500" min="200" step="1">
                <label for="drawerHeightInput">Hoogte (H)</label>
                <input type="number" id="drawerHeightInput" value="50" min="20" step="1">
            </div>
            
            <button id="updateButton" onclick="updateDrawerDimensions(true)">Pas Lade Aan</button>
            
            <hr style="margin: 15px 0;">
            <p style="font-weight: bold; margin-bottom: 5px;">Indeling Splitsen/Bewerken</p>
            <div class="button-group">
                <button id="addDividerV_Partial" onclick="startAddDivider('partial_vertical')">(V) Splits (Partieel)</button>
                <button id="addDividerH_Partial" onclick="startAddDivider('partial_horizontal')">(H) Splits (Partieel)</button>
            </div>
            <div class="button-group">
                <button id="addDividerV_Full" onclick="startAddDivider('full_vertical')">(V) Splits (Volledig)</button>
                <button id="addDividerH_Full" onclick="startAddDivider('full_horizontal')">(H) Splits (Volledig)</button>
            </div>
                     
            <button id="resetButton" onclick="resetLayout()">Reset (1 Vak)</button>
            
            <button id="deleteDividerButton" onclick="startDeleteDivider()">üóëÔ∏è Verwijder Lat</button>

            <hr style="margin: 15px 0;">
            <button id="exportButton" onclick="exportSawList()">‚¨áÔ∏è Productie JSON Download</button>
            <button id="renderDetailsButton" onclick="buildDetailedModel()">üîç Bekijk Verbindingen</button>
            <button id="toggleExplodedViewButton" onclick="toggleExplodedView()">‚áÜ Schuif In/Uit Elkaar</button>


            <div id="vakEditor" style="border-top: 1px solid #aaa; margin-top: 20px; padding-top: 15px;">
                <h3>Geselecteerd Vak</h3>
                <div class="input-group">
                    <label>Vak ID:</label>
                    <span id="vakIdDisplay">Geen</span>
                </div>
                <div class="input-group">
                    <label for="vakWidthInput">Breedte (mm) Binnenmaat</label>
                    <input type="number" id="vakWidthInput" step="1">
                </div>
                <div class="input-group">
                    <label for="vakHeightInput">Diepte (mm) Binnenmaat</label>
                    <input type="number" id="vakHeightInput" step="1">
                </div>
                <button id="updateVakButton" onclick="handleVakUpdateFromSidebar()">Pas Vak Aan</button>
            </div>
        </div>
        </div>
    
    <div id="loadingOverlay">Texturen laden...</div>

    <footer id="footer">
        &copy; 2025 Uw Bedrijfsnaam. Alle rechten voorbehouden. Configuratie Engine door AI.
    </footer>

    <script>
        // *** START VAN ALLE JAVASCRIPT LOGICA ***

        // --- Globale Setup en Parameters ---
        let scene, camera, renderer, controls, dragControls;
        let labelRenderer; 
        let raycaster; 
        let mouse; 

        const WALL_THICKNESS = 9;
        const BODEM_DIKTE = 4;
        let LADE_HOOGTE = 50; 
        
        const MIN_DIMENSION = 40;
        const TOLERANCE = 1; 
        const SNAP_THRESHOLD = 5; 
        const MIDDLE_SNAP_THRESHOLD = 10; 
        
        let currentLayoutData = []; 
        let wallsArray = []; 
        let clickableVakMeshes = []; 
        let baseMesh; 

        let DRAW_W = 600; 
        let DRAW_D = 500; 
        
        let selectedVakId = null; 
        let addDividerMode = null; 
        let isDeletingDivider = false; 
        let nextVakId = 2; 

        let isExplodedView = true;

        let textureLoader;
        let woodTexture;
        let activeWoodMaterial; 

        function getWoodMaterial(materialKey) {
            let baseColor;

            switch (materialKey) {
                case 'light_oak':
                    baseColor = 0xffffff; 
                    break;
                case 'dark_walnut':
                    baseColor = 0x7B5833; 
                    break;
                default:
                    baseColor = 0xffffff;
            }

            if (woodTexture) {
                woodTexture.wrapS = THREE.ClampToEdgeWrapping;
                woodTexture.wrapT = THREE.ClampToEdgeWrapping;
                woodTexture.repeat.set(1, 1);
                
                return new THREE.MeshLambertMaterial({ 
                    map: woodTexture,
                    color: baseColor 
                });
            } else {
                return new THREE.MeshLambertMaterial({ color: baseColor });
            }
        }

        function updateDrawerDimensions(resetLayoutData = false) {
            const newW = parseInt(document.getElementById('drawerWidthInput').value);
            const newD = parseInt(document.getElementById('drawerDepthInput').value);
            const newH = parseInt(document.getElementById('drawerHeightInput').value); 

            if (isNaN(newW) || isNaN(newD) || isNaN(newH) || newW < 200 || newD < 200 || newH < 20) {
                if (resetLayoutData) { 
                    alert("Voer geldige afmetingen in (min B/D: 200mm, min H: 20mm).");
                }
                renderDrawerLayout(currentLayoutData, DRAW_W, DRAW_D, WALL_THICKNESS, LADE_HOOGTE);
                return;
            }
            
            DRAW_W = newW;
            DRAW_D = newD;
            LADE_HOOGTE = newH; 
            
            if (resetLayoutData) { 
                const innerW = DRAW_W - (2 * WALL_THICKNESS);
                const innerD = DRAW_D - (2 * WALL_THICKNESS);

                if (innerW < MIN_DIMENSION || innerD < MIN_DIMENSION) {
                    alert("Fout: Lade is te klein voor de muurdikte. Maak de lade groter.");
                    return;
                }

                currentLayoutData = [
                    {
                        id: 'V1',
                        x: 0, 
                        y: 0, 
                        width: innerW, 
                        height: innerD 
                    }
                ];
                nextVakId = 2; 
            }

            const selectedMaterialKey = document.getElementById('materialSelect').value;
            activeWoodMaterial = getWoodMaterial(selectedMaterialKey);

            renderDrawerLayout(currentLayoutData, DRAW_W, DRAW_D, WALL_THICKNESS, LADE_HOOGTE);
            
            document.getElementById('vakEditor').style.display = 'none';
            selectedVakId = null;
            document.getElementById('layout-status').innerText = `Lade: ${DRAW_W}x${DRAW_D}x${LADE_HOOGTE}mm | Vakken: ${currentLayoutData.length}`;

            if (resetLayoutData) {
                camera.position.set(0, DRAW_D * 1.5, 0); 
                camera.lookAt(0, 0, 0); 
                camera.updateProjectionMatrix(); 
            }
        }

        function resetLayout() {
            updateDrawerDimensions(true);
        }

        function findDirectNeighbors(wallMesh, layoutData) {
            const isVertical = wallMesh.userData.isVertical;
            const wallPosition = isVertical ? wallMesh.position.x : wallMesh.position.z;
            
            const axis = isVertical ? 'x' : 'y';
            const dim = isVertical ? 'width' : 'height';
            const crossAxis_Data = isVertical ? 'y' : 'x';
            const crossDim_Data = isVertical ? 'height' : 'width';

            const crossAxis_3D = isVertical ? 'z' : 'x';
            const crossDim_Geom = isVertical ? 'depth' : 'width';

            const vakAList = [];
            const vakBList = [];

            for (const vak of layoutData) {
                const vakCenter_Data = vak[axis];
                const vakSize_Data = vak[dim];
                
                const expectedWallB = vakCenter_Data + vakSize_Data / 2 + WALL_THICKNESS / 2;
                if (Math.abs(expectedWallB - wallPosition) < TOLERANCE) {
                    const wallMin = wallMesh.position[crossAxis_3D] - wallMesh.geometry.parameters[crossDim_Geom] / 2;
                    const wallMax = wallMesh.position[crossAxis_3D] + wallMesh.geometry.parameters[crossDim_Geom] / 2;
                    const vakMin = vak[crossAxis_Data] - vak[crossDim_Data] / 2;
                    const vakMax = vak[crossAxis_Data] + vak[crossDim_Data] / 2;
                    
                    if (Math.max(wallMin, vakMin) < Math.min(wallMax, vakMax) - TOLERANCE) {
                          vakAList.push(vak);
                    }
                }
                
                const expectedWallA = vakCenter_Data - vakSize_Data / 2 - WALL_THICKNESS / 2;
                if (Math.abs(expectedWallA - wallPosition) < TOLERANCE) {
                    const wallMin = wallMesh.position[crossAxis_3D] - wallMesh.geometry.parameters[crossDim_Geom] / 2;
                    const wallMax = wallMesh.position[crossAxis_3D] + wallMesh.geometry.parameters[crossDim_Geom] / 2;
                    const vakMin = vak[crossAxis_Data] - vak[crossDim_Data] / 2;
                    const vakMax = vak[crossAxis_Data] + vak[crossDim_Data] / 2;
                    
                    if (Math.max(wallMin, vakMin) < Math.min(wallMax, vakMax) - TOLERANCE) {
                        vakBList.push(vak);
                    }
                }
            }

            if (vakAList.length > 0 && vakBList.length > 0) {
                return [vakAList, vakBList];
            }
            return null; 
        }

        function renderDrawerLayout(layoutData, totalW, totalD, wallT, ladeH) {
            
            const detailedLayout = scene.getObjectByName('DetailedLayout');
            if (detailedLayout) {
                scene.remove(detailedLayout); 
            }
            
            document.getElementById('toggleExplodedViewButton').style.display = 'none'; 
            
            const oldLayout = scene.getObjectByName('DrawerLayout');

            if (oldLayout) {
                oldLayout.children.slice(0).forEach(child => {
                    if (child.isCSS2DObject) {
                        child.parent.remove(child);
                    }
                });
                scene.remove(oldLayout);
            }

            const layoutGroup = new THREE.Group();
            layoutGroup.name = 'DrawerLayout';
            wallsArray = []; 
            clickableVakMeshes = []; 

            const materialToUse = activeWoodMaterial;
            const clickableVakMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }); 
            
            const baseDepth = BODEM_DIKTE; 
            const externalWallHeight = ladeH; 
            const externalWallYPos = ladeH / 2; 

            const internalWallHeight = ladeH - baseDepth; 
            const internalWallYPos = baseDepth + (internalWallHeight / 2); 

            // 1. Bodemplaat 
            const baseWidth = totalW - (2 * wallT);
            const basePlateDepth = totalD - (2 * wallT);
            
            const baseGeometry = new THREE.BoxGeometry(baseWidth, baseDepth, basePlateDepth);
            baseMesh = new THREE.Mesh(baseGeometry, materialToUse); 
            baseMesh.position.set(0, baseDepth / 2, 0); 
            baseMesh.name = "DrawerBase"; 
            layoutGroup.add(baseMesh);

            // 2. Buitenmuren 
            const placedBoundaries = new Set(); 
            placeWallIfNew(wallT, totalD, -totalW / 2 + wallT / 2, 0, true, placedBoundaries, materialToUse, externalWallHeight, externalWallYPos, layoutGroup);
            placeWallIfNew(wallT, totalD,  totalW / 2 - wallT / 2, 0, true, placedBoundaries, materialToUse, externalWallHeight, externalWallYPos, layoutGroup);
            placeWallIfNew(totalW, wallT, 0, -totalD / 2 + wallT / 2, false, placedBoundaries, materialToUse, externalWallHeight, externalWallYPos, layoutGroup);
            placeWallIfNew(totalW, wallT, 0,  totalD / 2 - wallT / 2, false, placedBoundaries, materialToUse, externalWallHeight, externalWallYPos, layoutGroup);

            // 3. Interne Muren, Labels, en Klikvlakken
            layoutData.forEach(vak => {
                const rightWallX = vak.x + vak.width / 2 + wallT / 2;
                if (rightWallX < (totalW / 2 - wallT / 2 - TOLERANCE)) {
                    const wall = placeWallIfNew(wallT, vak.height, rightWallX, vak.y, true, placedBoundaries, materialToUse, internalWallHeight, internalWallYPos, layoutGroup); 
                    if (wall) wallsArray.push(wall);
                }
                
                const frontWallZ = vak.y + vak.height / 2 + wallT / 2;
                if (frontWallZ < (totalD / 2 - wallT / 2 - TOLERANCE)) {
                    const wall = placeWallIfNew(vak.width, wallT, vak.x, frontWallZ, false, placedBoundaries, materialToUse, internalWallHeight, internalWallYPos, layoutGroup); 
                    if (wall) wallsArray.push(wall);
                }

                // 3D Dimensie Labels (code verwijderd voor beknoptheid)
                
                // Onzichtbare Klikvlakken
                const vakPlaneGeo = new THREE.PlaneGeometry(vak.width, vak.height);
                const vakPlane = new THREE.Mesh(vakPlaneGeo, clickableVakMaterial);
                vakPlane.position.set(vak.x, baseDepth, vak.y); 
                vakPlane.rotation.x = -Math.PI / 2; 
                vakPlane.name = "ClickableVak";
                vakPlane.userData.vakId = vak.id; 
                layoutGroup.add(vakPlane);
                clickableVakMeshes.push(vakPlane); 
            });

            scene.add(layoutGroup);
            setupDragControls(); 
        }
        
        function placeWallIfNew(dim1, dim2, pos1, pos2, isVertical, placedBoundaries, wallMaterial, wallTotalHeight, wallYCenter, layoutGroup) {
            const boundaryKey = `${pos1.toFixed(1)},${pos2.toFixed(1)},${isVertical}`;
            if (placedBoundaries.has(boundaryKey)) return null;

            let geometry, position;
            if (isVertical) {
                geometry = new THREE.BoxGeometry(dim1, wallTotalHeight, dim2);
                position = new THREE.Vector3(pos1, wallYCenter, pos2);
            } else { 
                geometry = new THREE.BoxGeometry(dim1, wallTotalHeight, dim2);
                position = new THREE.Vector3(pos1, wallYCenter, pos2);
            }

            const wall = new THREE.Mesh(geometry, wallMaterial); 
            wall.position.copy(position);
            wall.userData.isVertical = isVertical;
            wall.userData.initialX = position.x;
            wall.userData.initialY = position.y; 
            wall.userData.initialZ = position.z;
            
            layoutGroup.add(wall);
            placedBoundaries.add(boundaryKey);
            return wall;
        }

        // --- Dynamisch Slepen Functies (verkort) ---
        function setupDragControls() {
            if (dragControls) { dragControls.dispose(); }
            dragControls = new THREE.DragControls(wallsArray, camera, renderer.domElement);
            
            dragControls.addEventListener('dragstart', function (event) {
                if (isDeletingDivider) { return; } 
                controls.enabled = false;
                const mesh = event.object;
                mesh.userData.dragAxis = mesh.userData.isVertical ? 'x' : 'z'; 
                dragControls.axis = mesh.userData.dragAxis.toUpperCase(); 
                mesh.position.y = mesh.userData.initialY; 
                mesh.userData.lastGoodX = mesh.position.x;
                mesh.userData.lastGoodZ = mesh.position.z;
                // ... (rest van de dragstart logica) ...
                
                const neighbors = findDirectNeighbors(mesh, currentLayoutData);
                if (neighbors) {
                    mesh.userData.vakAList = neighbors[0];
                    mesh.userData.vakBList = neighbors[1];
                } else {
                    controls.enabled = true; 
                    dragControls.axis = null;
                }
            });
            
            dragControls.addEventListener('drag', function (event) { /* ... (drag logica) ... */ });

            dragControls.addEventListener('dragend', function (event) { /* ... (dragend logica) ... */ });
        }
        
        // --- VAK SELECTIE FUNCTIES (verkort) ---
        function findVakAtPoint(x, z) { /* ... */ }
        function selectVak(vak) { /* ... */ }
        function handleVakUpdateFromSidebar() { /* ... */ }
        function findDirectNeighbor(vak, direction) { /* ... */ }

        // --- FUNCTIES VOOR SPLITSEN EN VERWIJDEREN (verkort) ---
        function startAddDivider(mode) { /* ... */ }
        function startDeleteDivider() { /* ... */ }
        function splitVak(vak, direction, splitCoord) { /* ... */ }
        function mergeVaks(vakAList, vakBList, isVertical) { /* ... */ }
        function onSceneClick(event) { /* ... */ }
        function resetClickMode(hideEditor = true) { /* ... */ }
        
        // --- HELPER FUNCTIE: BEREKENT ALLE ONDERDELEN ---
        function getLayoutParts() {
            const wallT = WALL_THICKNESS;
            const baseT = BODEM_DIKTE;
            const ladeH = LADE_HOOGTE;
            const totalW = DRAW_W;
            const totalD = DRAW_D;
            
            const innerWallH = ladeH - baseT;
            const innerW = totalW - (2 * wallT);
            const innerD = totalD - (2 * wallT);
            
            const yPosWall = ladeH / 2;
            const yPosInnerWall = baseT + innerWallH / 2;
            const yPosBase = baseT / 2;
            
            let parts = { outerWalls: [], basePlate: null, internalDividers: [] };

            parts.basePlate = { id: 'base', type: 'base', width: innerW, height: baseT, depth: innerD, position: new THREE.Vector3(0, yPosBase, 0) };

            parts.outerWalls.push({ id: 'wall_left', type: 'wall', isVertical: true, width: wallT, height: ladeH, depth: totalD, position: new THREE.Vector3(-totalW / 2 + wallT / 2, yPosWall, 0) });
            parts.outerWalls.push({ id: 'wall_right', type: 'wall', isVertical: true, width: wallT, height: ladeH, depth: totalD, position: new THREE.Vector3(totalW / 2 - wallT / 2, yPosWall, 0) });
            parts.outerWalls.push({ id: 'wall_back', type: 'wall', isVertical: false, width: innerW, height: ladeH, depth: wallT, position: new THREE.Vector3(0, yPosWall, -totalD / 2 + wallT / 2) });
            parts.outerWalls.push({ id: 'wall_front', type: 'wall', isVertical: false, width: innerW, height: ladeH, depth: wallT, position: new THREE.Vector3(0, yPosWall, totalD / 2 - wallT / 2) });

            const placedBoundaries = new Set();
            currentLayoutData.forEach(vak => {
                const rightWallX = vak.x + vak.width / 2 + wallT / 2;
                if (rightWallX < (totalW / 2 - wallT / 2 - TOLERANCE)) {
                    const boundaryKey = `v,${rightWallX.toFixed(1)},${vak.y.toFixed(1)},${vak.height.toFixed(1)}`;
                    if (!placedBoundaries.has(boundaryKey)) {
                        placedBoundaries.add(boundaryKey);
                        parts.internalDividers.push({ id: `divider_${boundaryKey}`, type: 'divider_v', isVertical: true, width: wallT, height: innerWallH, depth: vak.height, position: new THREE.Vector3(rightWallX, yPosInnerWall, vak.y) });
                    }
                }
                
                const frontWallZ = vak.y + vak.height / 2 + wallT / 2;
                if (frontWallZ < (totalD / 2 - wallT / 2 - TOLERANCE)) {
                    const boundaryKey = `h,${frontWallZ.toFixed(1)},${vak.x.toFixed(1)},${vak.width.toFixed(1)}`;
                    if (!placedBoundaries.has(boundaryKey)) {
                        placedBoundaries.add(boundaryKey);
                        parts.internalDividers.push({ id: `divider_${boundaryKey}`, type: 'divider_h', isVertical: false, width: vak.width, height: innerWallH, depth: wallT, position: new THREE.Vector3(vak.x, yPosInnerWall, frontWallZ) });
                    }
                }
            });
            
            return parts;
        }

        // --- FUNCTIE VOOR JSON EXPORT (VOOR CNC) ---
        function exportSawList() {
            const parts = getLayoutParts();
            let productionData = [];
            const wallT = WALL_THICKNESS;
            const dadoDepth = wallT / 2; 
            const internalDividers = parts.internalDividers;
            const verticalDividers = internalDividers.filter(p => p.isVertical);
            const horizontalDividers = internalDividers.filter(p => !p.isVertical);
            let allCuts = {}; 
            const addCut = (targetId, cutData) => { if (!allCuts[targetId]) allCuts[targetId] = []; allCuts[targetId].push(cutData); };

            // 1.1 Dado (Gleuf) Bewerkingen (vereenvoudigde code)
            internalDividers.forEach(divider => {
                const pos = divider.position;
                const outerWalls = parts.outerWalls.reduce((acc, w) => ({ ...acc, [w.id]: w.position }), {});
                if (!divider.isVertical) {
                    const halfLen = divider.width / 2;
                    if (Math.abs((pos.x - halfLen) - (outerWalls['wall_left'].x + wallT / 2)) < TOLERANCE) { addCut('wall_left', { type: 'dado', axis: 'z', center: pos.z.toFixed(2), length: divider.depth.toFixed(2), depth: dadoDepth.toFixed(2) }); }
                    if (Math.abs((pos.x + halfLen) - (outerWalls['wall_right'].x - wallT / 2)) < TOLERANCE) { addCut('wall_right', { type: 'dado', axis: 'z', center: pos.z.toFixed(2), length: divider.depth.toFixed(2), depth: dadoDepth.toFixed(2) }); }
                }
                if (divider.isVertical) {
                    const halfLen = divider.depth / 2;
                    if (Math.abs((pos.z - halfLen) - (outerWalls['wall_back'].z + wallT / 2)) < TOLERANCE) { addCut('wall_back', { type: 'dado', axis: 'x', center: pos.x.toFixed(2), length: divider.width.toFixed(2), depth: dadoDepth.toFixed(2) }); }
                    if (Math.abs((pos.z + halfLen) - (outerWalls['wall_front'].z - wallT / 2)) < TOLERANCE) { addCut('wall_front', { type: 'dado', axis: 'x', center: pos.x.toFixed(2), length: divider.width.toFixed(2), depth: dadoDepth.toFixed(2) }); }
                }
            });

            // 1.2 Half-Lap (Halfhouts) Bewerkingen (vereenvoudigde code)
            verticalDividers.forEach(vDiv => {
                horizontalDividers.forEach(hDiv => {
                    const v_minX = vDiv.position.x - vDiv.width / 2;
                    const v_maxX = vDiv.position.x + vDiv.width / 2;
                    const v_minZ = vDiv.position.z - vDiv.depth / 2;
                    const v_maxZ = vDiv.position.z + vDiv.depth / 2;
                    const h_minX = hDiv.position.x - hDiv.width / 2;
                    const h_maxX = hDiv.position.x + hDiv.width / 2;
                    const h_minZ = hDiv.position.z - hDiv.depth / 2;
                    const h_maxZ = hDiv.position.z + hDiv.depth / 2;
                    const intersects = (v_minX < h_maxX && v_maxX > h_minX && v_minZ < h_maxZ && v_maxZ > h_minZ);

                    if (intersects) {
                        const lapDepth = (vDiv.height / 2).toFixed(2);
                        addCut(hDiv.id, { type: 'lap', center: vDiv.position.x.toFixed(2), length: wallT.toFixed(2), depth: lapDepth, side: 'top' });
                        addCut(vDiv.id, { type: 'lap', center: hDiv.position.z.toFixed(2), length: wallT.toFixed(2), depth: lapDepth, side: 'bottom' });
                    }
                });
            });

            // --- 2. Combineer Part Data met Cut Data ---
            const allParts = [...parts.outerWalls, ...parts.internalDividers, parts.basePlate];
            allParts.forEach(part => {
                const partId = part.id;
                let dims;
                if (part.type === 'base') { dims = { L: part.width.toFixed(2), D: part.depth.toFixed(2), T: part.height.toFixed(2) }; } 
                else { const length = part.isVertical ? part.depth : part.width; const thickness = part.isVertical ? part.width : part.depth; dims = { L: length.toFixed(2), H: part.height.toFixed(2), T: thickness.toFixed(2) }; }
                productionData.push({ id: partId, description: part.type === 'base' ? "Bodemplaat" : (part.id.includes('wall') ? `Buitenwand ${partId.split('_')[1]}` : 'Interne Lat'), dims: dims, cuts: allCuts[partId] || [] });
            });
            
            // --- 3. Exporteer als JSON ---
            const jsonString = JSON.stringify(productionData, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lade_productiedata_${DRAW_W}x${DRAW_D}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            document.getElementById('layout-status').innerText = `‚úÖ Productiedata ge√´xporteerd als JSON.`;
        }
        
        // --- FUNCTIE: Wrapper om het gedetailleerde model te bouwen (MET CAMERA) ---
        function buildDetailedModel() {
            isExplodedView = true; 
            renderDetailedModel(); 
            document.getElementById('toggleExplodedViewButton').style.display = 'block';

            const detailedGroup = scene.getObjectByName('DetailedLayout');
            if (!detailedGroup) return; 

            const boundingBox = new THREE.Box3().setFromObject(detailedGroup);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            boundingBox.getCenter(center);
            boundingBox.getSize(size);

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5; 
            
            camera.position.set(center.x + cameraZ, center.y + cameraZ, center.z);
            controls.target.copy(center);
            controls.update();
        }

        // --- FUNCTIE: Wisselt tussen explosie en gemonteerd ---
        function toggleExplodedView() {
            const detailedGroup = scene.getObjectByName('DetailedLayout');
            if (!detailedGroup) return; 

            isExplodedView = !isExplodedView; 

            detailedGroup.children.forEach(mesh => {
                if (mesh.userData.assembledPosition && mesh.userData.explosionVector) {
                    if (isExplodedView) {
                        mesh.position.copy(mesh.userData.assembledPosition).add(mesh.userData.explosionVector);
                    } else {
                        mesh.position.copy(mesh.userData.assembledPosition);
                    }
                }
            });
            
            const statusText = isExplodedView ? " (explosie-weergave)" : " (gemonteerd)";
            document.getElementById('layout-status').innerText = "Gedetailleerd model getoond" + statusText;
        }

        // --- FUNCTIE: GEDETAILLEERDE RENDERING (MET CSG & FIX) ---
        function renderDetailedModel() {
            const simpleLayout = scene.getObjectByName('DrawerLayout');
            if (simpleLayout) simpleLayout.visible = false;
            
            const oldDetailedLayout = scene.getObjectByName('DetailedLayout');
            if (oldDetailedLayout) scene.remove(oldDetailedLayout);
            
            const detailedGroup = new THREE.Group();
            detailedGroup.name = 'DetailedLayout';
            
            const materialToUse = getWoodMaterial(document.getElementById('materialSelect').value);
            const EXPLOSION_FACTOR = 50; 
            
            const parts = getLayoutParts();
            const wallT = WALL_THICKNESS;
            
            const FIX_OVERLAP = 1; 
            const dadoDepth = (wallT / 2) + FIX_OVERLAP; 
            
            let meshes = {};
            parts.outerWalls.forEach(part => {
                const geo = new THREE.BoxGeometry(part.width, part.height, part.depth);
                const mesh = new THREE.Mesh(geo, materialToUse);
                mesh.position.copy(part.position);
                mesh.userData.part = part; 
                meshes[part.id] = mesh;
            });
            const basePart = parts.basePlate;
            const baseGeo = new THREE.BoxGeometry(basePart.width, basePart.height, basePart.depth);
            const baseMesh = new THREE.Mesh(baseGeo, materialToUse);
            baseMesh.position.copy(basePart.position);
            baseMesh.userData.part = basePart; 
            meshes[basePart.id] = baseMesh;
            parts.internalDividers.forEach(part => {
                const geo = new THREE.BoxGeometry(part.width, part.height, part.depth);
                const mesh = new THREE.Mesh(geo, materialToUse);
                mesh.position.copy(part.position);
                mesh.userData.part = part;
                meshes[part.id] = mesh;
            });

            // STAP 3: Bereken verbindingen (Dados/Gleuven)
            let dadoCutters = [];
            parts.internalDividers.forEach(divider => {
                const pos = divider.position;
                const cutterGeo = new THREE.BoxGeometry(
                    divider.isVertical ? dadoDepth : divider.width,
                    divider.height,
                    divider.isVertical ? divider.depth : dadoDepth
                );
                let cutterMesh = null;
                const outerWalls = parts.outerWalls.reduce((acc, w) => ({ ...acc, [w.id]: w.position }), {});

                if (!divider.isVertical) {
                    const halfLen = divider.width / 2;
                    if (Math.abs((pos.x - halfLen) - (outerWalls['wall_left'].x + wallT / 2)) < TOLERANCE) {
                        cutterMesh = new THREE.Mesh(cutterGeo);
                        let cutterPos = new THREE.Vector3(outerWalls['wall_left'].x + (FIX_OVERLAP / 2), pos.y, pos.z);
                        cutterMesh.position.copy(cutterPos);
                        dadoCutters.push({ targetId: 'wall_left', cutter: cutterMesh });
                    }
                    if (Math.abs((pos.x + halfLen) - (outerWalls['wall_right'].x - wallT / 2)) < TOLERANCE) {
                        cutterMesh = new THREE.Mesh(cutterGeo);
                        let cutterPos = new THREE.Vector3(outerWalls['wall_right'].x - (FIX_OVERLAP / 2), pos.y, pos.z);
                        cutterMesh.position.copy(cutterPos);
                        dadoCutters.push({ targetId: 'wall_right', cutter: cutterMesh });
                    }
                }
                if (divider.isVertical) {
                    const halfLen = divider.depth / 2;
                    if (Math.abs((pos.z - halfLen) - (outerWalls['wall_back'].z + wallT / 2)) < TOLERANCE) {
                        cutterMesh = new THREE.Mesh(cutterGeo);
                        let cutterPos = new THREE.Vector3(pos.x, pos.y, outerWalls['wall_back'].z + (FIX_OVERLAP / 2));
                        cutterMesh.position.copy(cutterPos);
                        dadoCutters.push({ targetId: 'wall_back', cutter: cutterMesh });
                    }
                    if (Math.abs((pos.z + halfLen) - (outerWalls['wall_front'].z - wallT / 2)) < TOLERANCE) {
                        cutterMesh = new THREE.Mesh(cutterGeo);
                        let cutterPos = new THREE.Vector3(pos.x, pos.y, outerWalls['wall_front'].z - (FIX_OVERLAP / 2));
                        cutterMesh.position.copy(cutterPos);
                        dadoCutters.push({ targetId: 'wall_front', cutter: cutterMesh });
                    }
                }
            });

            // STAP 4: Bereken verbindingen (Half-Laps)
            let lapCutters = [];
            const verticalDividers = parts.internalDividers.filter(p => p.isVertical);
            const horizontalDividers = parts.internalDividers.filter(p => !p.isVertical);
            verticalDividers.forEach(vDiv => {
                horizontalDividers.forEach(hDiv => {
                    const v_minX = vDiv.position.x - vDiv.width / 2;
                    const v_maxX = vDiv.position.x + vDiv.width / 2;
                    const v_minZ = vDiv.position.z - vDiv.depth / 2;
                    const v_maxZ = vDiv.position.z + vDiv.depth / 2;
                    const h_minX = hDiv.position.x - hDiv.width / 2;
                    const h_maxX = hDiv.position.x + hDiv.width / 2;
                    const h_minZ = hDiv.position.z - hDiv.depth / 2;
                    const h_maxZ = hDiv.position.z + hDiv.depth / 2;
                    const intersects = (v_minX < h_maxX && v_maxX > h_minX && v_minZ < h_maxZ && v_maxZ > h_minZ);
                    if (intersects) {
                        const intersectX = vDiv.position.x;
                        const intersectZ = hDiv.position.z;
                        const intersectY = vDiv.position.y;
                        const intersectHeight = vDiv.height;

                        const cutterHeight = (intersectHeight / 2) + FIX_OVERLAP;

                        const cutterTopGeo = new THREE.BoxGeometry(wallT, cutterHeight, wallT);
                        const cutterTop = new THREE.Mesh(cutterTopGeo);
                        cutterTop.position.set(intersectX, intersectY + (intersectHeight / 4) + (FIX_OVERLAP / 2), intersectZ);
                        lapCutters.push({ targetId: hDiv.id, cutter: cutterTop });

                        const cutterBottomGeo = new THREE.BoxGeometry(wallT, cutterHeight, wallT);
                        const cutterBottom = new THREE.Mesh(cutterBottomGeo);
                        cutterBottom.position.set(intersectX, intersectY - (intersectHeight / 4) - (FIX_OVERLAP / 2), intersectZ);
                        lapCutters.push({ targetId: vDiv.id, cutter: cutterBottom });
                    }
                });
            });

            // STAP 5: Voer alle CSG-operaties uit
            const allCutters = dadoCutters.concat(lapCutters);
            const cuttersByTarget = allCutters.reduce((acc, op) => {
                if (!acc[op.targetId]) acc[op.targetId] = [];
                acc[op.targetId].push(op.cutter);
                return acc;
            }, {});
            try {
                Object.keys(meshes).forEach(id => {
                    let targetMesh = meshes[id];
                    if (cuttersByTarget[id]) {
                        targetMesh.updateMatrix(); 
                        let cutters = cuttersByTarget[id];
                        
                        let combinedCutter = cutters[0];
                        combinedCutter.updateMatrix();
                        
                        if (cutters.length > 1) {
                            for (let i = 1; i < cutters.length; i++) {
                                cutters[i].updateMatrix();
                                combinedCutter = CSG.union(combinedCutter, cutters[i]);
                            }
                        }

                        const processedMesh = CSG.subtract(targetMesh, combinedCutter);
                        processedMesh.userData = targetMesh.userData; 
                        meshes[id] = processedMesh; 
                    }
                });
            } catch (e) {
                console.error("Fout tijdens CSG-operatie:", e);
            }

            // STAP 6: Voeg meshes toe aan scene & pas explosie toe
            Object.values(meshes).forEach(mesh => {
                const part = mesh.userData.part; 
                
                mesh.userData.assembledPosition = mesh.position.clone();
                let explosionVector = new THREE.Vector3(0, 0, 0); 
                
                if (part && part.id !== 'base') { 
                    if (part.type === 'wall') {
                        if (part.id === 'wall_left') explosionVector.x = -EXPLOSION_FACTOR;
                        if (part.id === 'wall_right') explosionVector.x = EXPLOSION_FACTOR;
                        if (part.id === 'wall_back') explosionVector.z = -EXPLOSION_FACTOR;
                        if (part.id === 'wall_front') explosionVector.z = EXPLOSION_FACTOR;
                    } 
                    else if (part.type.startsWith('divider')) {
                        if (part.position.x > TOLERANCE) explosionVector.x = EXPLOSION_FACTOR;
                        if (part.position.x < -TOLERANCE) explosionVector.x = -EXPLOSION_FACTOR;
                        if (part.position.z > TOLERANCE) explosionVector.z = EXPLOSION_FACTOR;
                        if (part.position.z < -TOLERANCE) explosionVector.z = -EXPLOSION_FACTOR;
                    }
                }
                
                mesh.userData.explosionVector = explosionVector;
                
                if (isExplodedView) {
                    mesh.position.add(explosionVector);
                }
                
                detailedGroup.add(mesh);
            });

            scene.add(detailedGroup);
            
            const statusText = isExplodedView ? " (explosie-weergave)" : " (gemonteerd)";
            document.getElementById('layout-status').innerText = "Gedetailleerd model gebouwd" + statusText;
        }

        // --- Initialisatie & Animatie ---

        function init() {
            try {
                const headerHeight = document.getElementById('header').offsetHeight;
                const footerHeight = document.getElementById('footer').offsetHeight;

                const container = document.getElementById('container');
                const width = container.clientWidth;
                const height = window.innerHeight - headerHeight - footerHeight;

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf4f4f4);
                
                camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 2000); 

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.zIndex = '1';
                container.appendChild(renderer.domElement);

                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(width, height);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0';
                labelRenderer.domElement.style.zIndex = '2'; 
                labelRenderer.domElement.style.pointerEvents = 'none'; 
                container.appendChild(labelRenderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(100, 500, 500); 
                scene.add(directionalLight);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                renderer.domElement.addEventListener('click', onSceneClick, false);
                
                const loadingManager = new THREE.LoadingManager();
                loadingManager.onStart = function (url, itemsLoaded, itemsTotal) {
                    document.getElementById('loadingOverlay').style.display = 'flex';
                };
                loadingManager.onLoad = function () {
                    document.getElementById('loadingOverlay').style.display = 'none';
                    updateDrawerDimensions(true); 
                };
                loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
                    document.getElementById('loadingOverlay').innerText = `Texturen laden... (${itemsLoaded}/${itemsTotal})`;
                };
                loadingManager.onError = function (url) {
                    console.error('Fout bij laden textuur:', url);
                    document.getElementById('loadingOverlay').innerText = `Fout bij laden textuur! (${url})`;
                    updateDrawerDimensions(true); 
                };

                textureLoader = new THREE.TextureLoader(loadingManager);
                textureLoader.setCrossOrigin('anonymous');

                woodTexture = textureLoader.load('https://images.pexels.com/photos/5776224/pexels-photo-5776224.png'); 
                
                activeWoodMaterial = getWoodMaterial(document.getElementById('materialSelect').value);

                animate();

                window.addEventListener('resize', onWindowResize, false);
            } catch (e) {
                alert("Er is een fatale fout opgetreden bij het initialiseren: ".concat(e.message));
                document.body.innerHTML = "Startfout: " + e.message; 
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera); 
        }

        function onWindowResize() {
            const headerHeight = document.getElementById('header').offsetHeight;
            const footerHeight = document.getElementById('footer').offsetHeight;
            const container = document.getElementById('container');
            const width = container.clientWidth;
            const height = window.innerHeight - headerHeight - footerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            labelRenderer.setSize(width, height); 
        }

        // Start de applicatie
        init();
    </script>
</body>
</html>
